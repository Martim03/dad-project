package dadkvs.server;

/* these imported classes are generated by the contract */
// import java.awt.color.ICC_Profile;
// import java.lang.classfile.instruction.ThrowInstruction;
import java.util.ArrayList;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxosServiceGrpc;
import dadkvs.util.CollectorStreamObserver;
import dadkvs.util.GenericResponseCollector;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

    DadkvsServerState server_state;
    CommitHandler commitHandler;
    int request_counter;
    int num_servers;
    int my_id;
    ManagedChannel[] channels;
    DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[] async_stubs;
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock(); // TODO needs to be readWrite? or just normal
                                                                       // lock?

    public DadkvsMainServiceImpl(DadkvsServerState state, CommitHandler handler, int my_id) {
        this.server_state = state;
        this.my_id = my_id;
        this.request_counter = 0;
        this.commitHandler = handler;
        this.num_servers = 5;
        this.channels = new ManagedChannel[this.num_servers];
        this.async_stubs = new DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub[this.num_servers];
        startComms();
    }

    @Override
    public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
        // for debug purposesd
        System.out.println("Receiving read request:" + request);

        int reqid = request.getReqid();
        int key = request.getKey();
        VersionedValue vv = this.server_state.store.read(key);

        DadkvsMain.ReadReply response = DadkvsMain.ReadReply.newBuilder()
                .setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {

        // for debug purposes
        System.out.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Receiving commit request at " + java.time.LocalDateTime.now() + ": " + request);

        int reqid = request.getReqid();
        int key1 = request.getKey1();
        int version1 = request.getVersion1();
        int key2 = request.getKey2();
        int version2 = request.getVersion2();
        int writekey = request.getWritekey();
        int writeval = request.getWriteval();

        // for debug purposes
        System.out.println("receiving:\n reqid " + reqid + " key1 " + key1 + " v1 " + version1 + " k2 " + key2 + " v2 "
                + version2 + " wk " + writekey + " writeval " + writeval);
        commitHandler.addRequest(request, responseObserver);

        if (server_state.i_am_leader == true) {
            System.out.println("I am the leader, sending commit order request");

            /*
             * TODO: New Paxos implementation logic
             * 
             * send phase1 request to all acceptor servers to prepare transaction
             * check for the validity of the majority to see if it is safe to proceed for
             * the commit
             * send phase2 request to all acceptor servers with the value to commit (order
             * number and req num)
             * check for the replies and if the majority of the servers have accepted the
             * value
             * send learn request to ALL servers to inform the commit has been completed and
             * its value, now they should commit the value to their local store
             * 
             */
            

            if( sendPhase1(reqid) == true) {
                sendPhase2();

            }

            DadkvsPaxos.commitOrderRequest.Builder commit_request = DadkvsPaxos.commitOrderRequest.newBuilder();

            rwLock.writeLock().lock();
            int currentOrder = -1;
            try {
                currentOrder = this.request_counter + 1; // TODO separate the incramentation of the request counter, to
                                                       // concern abotut the transactions that might "fail"
            } finally {
                rwLock.writeLock().unlock();
            }

            commit_request.setReqid(reqid).setOrderNum(currentOrder);

           
            
        }
        System.out.println("CHEGUEI AO FIM!!!!!!");
    }

    public void startComms() {
        String host = "localhost";
        int port = 8080;

        for (int i = 0; i < this.num_servers; i++) {
            String target = host + ":" + Integer.toString(port + i);
            channels[i] = ManagedChannelBuilder.forTarget(target).usePlaintext().build();
            async_stubs[i] = DadkvsPaxosServiceGrpc.newStub(channels[i]);
        }
    }


    public Boolean sendPhase1(int reqid){
        DadkvsPaxos.PhaseOneRequest.Builder phase1_request = DadkvsPaxos.PhaseOneRequest.newBuilder();
        phase1_request.setPhase1Config(0).setPhase1Index(this.request_counter).setPhase1Timestamp(this.my_id);   //TODO: change timestamp to apropriate value if the leader fails
        ArrayList<DadkvsPaxos.PhaseOneReply> phase1_responses = new ArrayList<>();
        GenericResponseCollector<DadkvsPaxos.PhaseOneReply> commit_collector = new GenericResponseCollector<>(
                    phase1_responses, this.num_servers);
        CollectorStreamObserver<DadkvsPaxos.PhaseOneReply> commit_observer = new CollectorStreamObserver<>(
                commit_collector);

        for (int i = 0; i < this.num_servers; i++) {
            this.async_stubs[i].phaseone(phase1_request.build(), commit_observer);
            System.out.println("Sending commit order request to server " + i + " with channel: "
                    + async_stubs[i].getChannel().toString());
        }

        commit_collector.waitForTarget(this.num_servers);
        int accepted = 0 ;
        for (int i = 0; i < this.num_servers; i++) {
            if(phase1_responses.get(0).getPhase1Accepted() == true) {
                accepted++;
            }
        }
        return accepted >= num_servers;
    }

    public Boolean sendPhase2(){
        DadkvsPaxos.PhaseTwoRequest.Builder phase2_request = DadkvsPaxos.PhaseTwoRequest.newBuilder();
        phase2_request.setPhase2Config(0).setPhase2Index(this.request_counter).setPhase2Timestamp(this.my_id).;
        ArrayList<DadkvsPaxos.PhaseOneReply> phase1_responses = new ArrayList<>();
        GenericResponseCollector<DadkvsPaxos.PhaseOneReply> commit_collector = new GenericResponseCollector<>(
                    phase1_responses, this.num_servers);
        CollectorStreamObserver<DadkvsPaxos.PhaseOneReply> commit_observer = new CollectorStreamObserver<>(
                commit_collector);

        for (int i = 0; i < this.num_servers; i++) {
            this.async_stubs[i].phaseone(phase1_request.build(), commit_observer);
            System.out.println("Sending commit order request to server " + i + " with channel: "
                    + async_stubs[i].getChannel().toString());
        }
    }
}
