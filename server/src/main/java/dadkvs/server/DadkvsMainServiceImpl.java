package dadkvs.server;

/* these imported classes are generated by the contract */
import java.util.HashMap;
import java.util.Map;

import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

    DadkvsServerState server_state;
    int               timestamp;
	Map<Integer, DadkvsMain.CommitRequest> request_map ;
	Map<Integer, Integer> request_order_map ;
	int 			  current_order;

    
    public DadkvsMainServiceImpl(DadkvsServerState state) {
        this.server_state = state;
		this.timestamp = 0;
		this.request_map = new HashMap<>();
		this.request_order_map = new HashMap<>();
		this.current_order = 0;
	}

    @Override
    public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {

	// for debug purposesd
	System.out.println("Receiving read request:" + request);

	// Estamos no read o que significa que temos que guardar o elemento no dicionário, e se ele for o leader tem que ele dar um número
	// mesmo assim, nesta função tem que existir algo que permita que o servidor execute isto ( ou seja , se for lider , manda um execute disso para outros servidores)
	// contador para dar a ordem de execução
	

	int reqid = request.getReqid();
	int key = request.getKey();
	VersionedValue vv = this.server_state.store.read(key);
	
	DadkvsMain.ReadReply response =DadkvsMain.ReadReply.newBuilder()
	    .setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();
	
	responseObserver.onNext(response);
	responseObserver.onCompleted();
    }

    @Override
    public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		// for debug purposes
		System.out.println("Receiving commit request:" + request);

		int reqid = request.getReqid();
		int key1 = request.getKey1();
		int version1 = request.getVersion1();
		int key2 = request.getKey2();
		int version2 = request.getVersion2();
		int writekey = request.getWritekey();
		int writeval = request.getWriteval();

		// for debug purposes
		System.out.println("receiving:\n reqid " + reqid + " key1 " + key1 + " v1 " + version1 + " k2 " + key2 + " v2 " + version2 + " wk " + writekey + " writeval " + writeval);
		
		request_map.put(reqid,request, responseObserver); // PUT AWAKES LOCKS
		// Guardar num dicionário

		if ( server_state.i_am_leader == true ) {
			// while(int i = 0 ; i < n_servers ; i++){
			// 	enviar aqui o pedido para os outros servidores com o proto type shit

			// }
		}


		// Istu tudo tem que estar numa thread à parte que corre at all times

		while( true ) {
			int requestid = request_order_map.get(variável_da_thread);
			if( !(requestid and request_map.containsKey(requestid)))  {
				wait(request_order_map) ; 
			}
			else {

				DadkvsMain.CommitRequest request = request_map.get(requestID) ;

				int reqid = request.getReqid();
				int key1 = request.getKey1();
				int version1 = request.getVersion1();
				int key2 = request.getKey2();
				int version2 = request.getVersion2();
				int writekey = request.getWritekey();
				int writeval = request.getWriteval();

				// for debug purposes
				System.out.println("executing:\n reqid " + reqid + " key1 " + key1 + " v1 " + version1 + " k2 " + key2 + " v2 " + version2 + " wk " + writekey + " writeval " + writeval);

				this.timestamp++;
				TransactionRecord txrecord = new TransactionRecord (request, version1, key2, version2, writekey, writeval, this.timestamp);
				boolean result = this.server_state.store.commit (txrecord);
				
				// for debug purposes
				System.out.println("Result is ready for request with reqid " + reqid);
				
				DadkvsMain.CommitReply response =DadkvsMain.CommitReply.newBuilder()
					.setReqid(reqid).setAck(result).build();
				
				responseObserver.onNext(response);
				responseObserver.onCompleted();
			}
		}
    }
}
